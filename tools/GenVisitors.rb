####################################################################################################
# Generate Visitor processing methods, from a C# source file with the Nodes' classes
####################################################################################################

# Commandline and configurable parameters

if ARGV.size < 1
	puts "Must specify Nodes C# source file"
	exit
end

$genfile="ASTProcessorGenerated.cs"
$genclassname="ASTProcessor"

$srcfilename=ARGV[0]
if !File.exist?($srcfilename)
	puts "File " + $srcfilename + " not found"
	exit
end


####################################################################################################
# Methods

ASTNode = Struct.new(:name, :fields) do
	def inspect 
		self.name + ":\n\t" << self.fields.join("\n\t") << "\n"
	end
	
	def print
		puts self.inspect + "\n"
	end
end


def gen_code(nodes, gen_method)
	arrcode = []
	arrcode << "// ======================================================================"
	arrcode << "// Base Processor/Visitor class, auto-generated							"
	arrcode << "// 	Aditional methods should be defined in another file					"
	arrcode << "// 	Do NOT edit this file												"
	arrcode << "// ======================================================================"
	arrcode << "using System;"
    arrcode << "using System.Collections.Generic;"
    arrcode << "using System.Text;"
    arrcode << ""
    arrcode << "namespace crosspascal.ast"
	arrcode << "{"
	arrcode << "\t" + "public abstract partial class " + $genclassname
	arrcode << "\t{"
	arrcode << "\t\t//	Complete interface to be implemented by any specific AST processor	"

	codeLines = nodes.map { |x| gen_concrete_visit(x) }
	codeLines.each do |x| x.insert(0, "\t\t") end
	text = codeLines.join("\n\t\t")
	arrcode << text
	
	arrcode << "\t}"
	arrcode << "}"
	arrcode 
end

def gen_abstract_visit(node)
	cname = node.name
	cfields = node.fields
	
	arrcode = []
	arrcode << "public abstract void Visit(" + cname  + " node);"
	arrcode 
end

def gen_concrete_visit(node)
	cname = node.name
	cfields = node.fields
	
	arrcode = []
	arrcode << "public virtual void Visit(" + cname  + " node)"
	arrcode << "{"
	
	for field in cfields
		arrcode << "\t" + "traverse(node." + field.split(' ')[1] + ");"
	end
	arrcode << "}"
	arrcode 
end


def process_class(name,body)
	# remove all methods
	rgxDecl	= '\w+\s+\w+\s*\([^)]*\)'
	rgxExt	= ':\s*\w+\s*\([^)]*\)'
	rgxBody	= '{[^}]*}'
	body.gsub! Regexp.new(rgxDecl+'\s*('+rgxExt+')?\s*('+rgxBody+')?'), ''
	fields = body.split(';')
	fields.each do |x| x.strip! end

	qualifs = ['public', 'private', 'protected', 'internal', 'virtual', 'abstract',
				'internal', 'partial', 'sealed', 'static', 'override', 'unsafe']
	fields.each do |x| qualifs.each do |y| x.gsub! Regexp.new(y+'\s*'), ''  end end 
	fields.reject!(&:empty?)
	
	# puts fields.map().inject('') {|x,y| x + y}
	fields
end


####################################################################################################
# Main

dirpath = File.dirname($srcfilename)
genfilename = dirpath+File::SEPARATOR+$genfile

nodelines = File.readlines($srcfilename).each { |x| x.strip! }
classes = Array.new

for i in 0 ... nodelines.size
	line = nodelines[i]
	
	if line.length > 1

		ma = /class\s+(\w+)(.*)/.match line
		if ma != nil
			# Enter class to process
			classname = ma[1]	# get 1st match result
			classtext = ''
				level = 0
			
			if (/{/ =~ line ) != nil
				line = /({.*)/.match(ma[2])[1]		# '{' after class line
			else
				i += 1
				line = nodelines[i]
			end
			
			while i < nodelines.size
				line.gsub! /\/\/.*/, ''		# remove 1-line comments
				classtext += line
				if ( /{/ =~ line ) != nil
					level += 1		# open block
				end
				if ( /}/ =~ line ) != nil
					level -= 1	# close  block
					if level == 0
						break
					end
				end
				i += 1
				line = nodelines[i]
			end
			classtext = classtext[1,classtext.size-2]
			
			fields = process_class(classname, classtext);
			node = ASTNode.new(classname,fields)
			#node.print
			classes.push(node)
		end
	end
end


genmethod = method(:gen_concrete_visit)	# to generate Visitors/Processors with virtual methods that traverse each field
#genmethod = method(:gen_abstract_visit))	# to generate Visitors/Processors with abstract methods without body

output = gen_code classes,genmethod

File.open(genfilename, "w").puts(output)

