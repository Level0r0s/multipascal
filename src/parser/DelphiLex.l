using System;
using System.Collections;
using System.Collections.Generic;
using System.IO;
using System.Text;
using System.Linq;

namespace crosspascal.parser
{

/**
 * Delphi Lexer
 * Generated by C# Flex, based on <a href="http://www.jflex.de/">JFlex</a>.
 */
 
%%

	// TODO make a debug option programatically configurable	
// %debug
// %standalone

	
	// %public %abstract
%class DelphiScanner
%implements Token, IScanner
//%extends 
%function token

%8bit
	// %unicode

// useless for C#
// %yylexthrow ScannerException

//%column
%line
//Delphi is case insensitive, but the stringstream has been converted to lowercase. Simpler and faster
//%ignorecase

// ------------------------------------------------------
// EOF treatment:
%integer	// eof type. same as: %type Int32

/*	// Use explicit <<EOF>> rules instead 
%eofval{
	// code to be injected in non-specified <STATE><<EOF>> rules
	return YYEOF;
%eofval}
*/

// %eofclose	// close the stream at EOF
%eof{
	// code to be injected in zzDoEOF() if (!zzEOfDone)
	zzEOFDone = false;	// revert changes of zzDoEOF()! Should only apply to the top-level stream
%eof}
// ------------------------------------------------------

%init{
	// code injected in the constructor
	// Inits the scanner
	InitLexer(@in);
%init}

%{
		// **********************************************
		// IScanner/yyLex interface:

		public bool advance () {
			return !zzAtEOF;
		}

		// public int token ();	// created by CSFlex
				
		public Object value () {
			return yylval;
		}

		public int yylineno() {
			return yyline;
		}

		// **********************************************
		// Yacc's message functions
		
		void yyprint(String msg)
		{
			Console.Out.WriteLine("[Line " + yyline + "] " + msg);
		}

		void yydebug(String msg)
		{
			if (DelphiParser.DebugLevel > 0)
				Console.Out.WriteLine("[Line " + yyline + "] " + msg);
		}
		
		void yyerror(String msg = "Unknown lexical error")
		{
		//	throw new ScannerException(yyline, msg);
			Console.Error.WriteLine("[ERROR lexical] " + msg + " in line " + yyline);
		}

		
		// **********************************************
		// Internal helper functions
			
		
		UInt64 GetInt(string str, int numbase)
		{
			try {
				return Convert.ToUInt64(str, numbase);
			}
			catch (OverflowException)
			{	yyerror("Value exceeds the maximum range for an integer constant (2^64)");
				return 0;
			}
		}
		
		Double GetReal(string str)
		{
			try {
				return Convert.ToDouble(str);
			}
			catch (OverflowException)
			{	yyerror("Value exceeds the maximum range for an floating-point constant");
				return 0.0;
			}
		}

		string GetDirectiveArg(string directive)
		{
			int ignlen = directive.Length + 2; // from: "{$"
			return yytext().Substring(ignlen, yylength()-1-ignlen).Trim();
		}	
		
		void InitLexer(TextReader sr)
		{
			stateNames = new string[] {
				"XASMCODESEC", "XFUNCW_PARAMS", "XFUNCW_RET", "XFUNCDIRECTS", "XFUNCEXTERN",
				"SFUNCDECL", "SPROPSPECS", "SPACKAGES" };

			yyreset(sr);
			// set yylval and text to null before each executing each rule's action
			PRE_ACTION_DEFAULT = () => { yylval = null; text = null; };
	
			stateStack.Push(INITIAL);
		}
%}


	// exclusive states
%x XASMCODESEC XFUNCW_PARAMS XFUNCW_RET XFUNCDIRECTS XFUNCEXTERN
	// inclusive states. shared with INITIAL
%s SFUNCDECL SPROPSPECS SPACKAGES

DEC     = [0-9]
HEXA    = [0-9a-f]
ID      = [0-9a-z_]
ID1		= [_a-z]
NL      = (\r|\n|\r\n)
	

%%


	/**************************************************************/
	/* Reserved keywords	*/

	/* file type */
library		{ return KW_LIBRARY; }
unit		{ return KW_UNIT; }
program		{ return KW_PROGRAM; }

	/* dependencies */
uses		{ return KW_USES; }
exports		{ return KW_EXPORTS; }

	/* units keywords */
interface	{ return KW_INTERF; }
implementation	{ return KW_IMPL; }
finalization	{ return KW_FINALIZ; }
initialization	{ return KW_INIT; }

	/* objects */
object		{ return KW_OBJECT; }
record		{ return KW_RECORD; }
class		{ return KW_CLASS; }
packed		{ return KW_PACKED; }		// packed struct
of			{ return KW_OF; }			// decl of types
out			{ return KW_OUT; }			// modifier of func params
absolute	{ return KW_ABSOLUTE; }		// modifier of variables
property	{ yypushstate(SPROPSPECS); return KW_PROPERTY; }
inherited	{ return KW_INHERITED; }	// call of base construcotr/methods

	/* functions */
function	{ yypushstate(XFUNCW_PARAMS); return KW_FUNCTION; }
procedure	{ yypushstate(XFUNCW_PARAMS); return KW_PROCEDURE; }
constructor	{ yypushstate(XFUNCW_PARAMS); return KW_CONSTRUCTOR; }
destructor	{ yypushstate(XFUNCW_PARAMS); return KW_DESTRUCTOR; }

	/* section headers */
const		{ return KW_CONST; }
var			{ return KW_VAR; }
threadvar	{ return KW_THRVAR; }
type		{ return KW_TYPE; }
resourcestring	{ return TYPE_RSCSTR; }

	/* blocks */
begin		{ return KW_BEGIN; }
end			{ return KW_END; }
with		{ return KW_WITH; }		// with x do ..
do			{ return KW_DO; }

	/* control flow: loops */
for			{ return KW_FOR; }
to			{ return KW_TO; }
downto		{ return KW_DOWNTO; }
repeat		{ return KW_REPEAT; }
until		{ return KW_UNTIL; }
while		{ return KW_WHILE; }
break		{ return KW_BREAK; }
continue	{ return KW_CONTINUE; }

	/* control flow: others */
if			{ return KW_IF; }
then		{ return KW_THEN; }
else		{ return KW_ELSE; }
case		{ return KW_CASE; }		/* switch */
goto		{ return KW_GOTO; }
label		{ return KW_LABEL; }

	/* control flow: exceptions */
raise		{ return KW_RAISE; }
at			{ return KW_AT; }	// ex: raise excpt at address
try			{ return KW_TRY; }
except		{ return KW_EXCEPT; }
finally		{ return KW_FINALLY; }
on			{ return KW_ON; }




	/**************************************************************
	 * Directives:
	 * Should be treated as identifiers instead of reserved keywords
	 **************************************************************/

 	/**************************************************************/
	// Lexical Scope for function directives

	// wait for function params or return (when function has no params)
<XFUNCW_PARAMS> {
	// function name
	{ID1}{ID}*	{ yylval = yytext(); return IDENTIFIER; }
	"."			{ return KW_DOT; }
	
	"("			{	switchstate(XFUNCW_RET);
					yypushstate(INITIAL);
					return LPAREN;
				}
	";"			{	switchstate(XFUNCDIRECTS);
					yybegin(XFUNCDIRECTS);
					return SCOL;
				}
	":"			{	switchstate(XFUNCDIRECTS);
					yypushstate(INITIAL);
					return COLON;
				}
	[ \t\n\r]+	{ }
	. 			{ // signal to leave this state
					yypopstate();
					yypushback(1);
				}
}

	// wait for function return
<XFUNCW_RET> {
	":"			{	switchstate(XFUNCDIRECTS);
					yypushstate(INITIAL);
					return COLON;
				}
	
	";"			{	switchstate(XFUNCDIRECTS);
					yybegin(XFUNCDIRECTS);
					return SCOL;
				}
				
	[ \t\n\r]+	{ }
	. 			{ // signal to leave this state
					yypopstate();
					yypushback(1);
				}
}
	
	// scan function directives. in the default state, emit them as identifiers
<XFUNCDIRECTS> {
		// function call conventions
	cdecl		{ return KW_CDECL; }
	pascal		{ return KW_PASCAL; }
	mwpascal	{ return KW_PASCAL; }
	register	{ return KW_REGISTER; }
	safecall	{ return KW_SAFECALL; }
	stdcall		{ return KW_STDCALL; }

		// function qualifiers
	abstract	{ return KW_ABSTRACT; }
	assembler	{ return KW_ASSEMBLER; }
	dynamic		{ return KW_DYNAMIC; }
	export		{ return KW_EXPORT; }
	forward		{ return KW_FORWARD; }
	inline		{ return KW_INLINE; }
	override	{ return KW_OVERRIDE; }
	overload	{ return KW_OVERLOAD; }
	reintroduce	{ return KW_REINTRODUCE; }
	virtual		{ return KW_VIRTUAL; }
	varargs		{ return KW_VARARGS; }
		// DOS deprecated
	far			{ return KW_FAR; }
	near		{ return KW_NEAR; }
	resident	{ return KW_RESIDENT; }
	
		// needs to chomp up the externa args
	external	{ yypushstate(XFUNCEXTERN); return KW_EXTERNAL; }
	
	";"			{ return SCOL; }
	[ \t\n\r]+	{ }

	// leave func directives:
	"="			{ yypopstate(); return KW_EQ; }
		// for IDs that start with a keyword part. ex: forward_dffdg
	{ID1}{ID}*	{ yypopstate(); yypushback(yylength()); }
	. 			{ yypopstate();	yypushback(1); }
}

	// process 'external' directive args
<XFUNCEXTERN> {
	name 		{ return KW_NAME; }
	'[^']*'		{ yylval = yytext().Substring(1, yylength()-2); return CONST_STR; }
	"."			{ return KW_DOT; }
	{ID1}{ID}*	{ yylval = yytext(); return IDENTIFIER; }
	
	";"			{ yypopstate(); return SCOL; }
	[ \t\n\r]+	{ }
	.			{ yyerror("Invalid char in external args: " + text + " (ASCII " + ((int) text[0]) +")"); }	
} 

	
 	/**************************************************************/
	// Lexical Scope for Properties directives	

<SPROPSPECS> {
	//	properties keywords
	default		{ return KW_DEFAULT; }
	index		{ return KW_INDEX; }
	implements	{ return KW_IMPLEMENTS; }
	name		{ return KW_NAME; }
	nodefault	{ return KW_NODEFAULT; }
	read		{ return KW_READ; }
	stored		{ return KW_STORED; }
	write		{ return KW_WRITE; }

	";" 		{ // signal to leave this state
					yypopstate();
					return SCOL;
				}
}


 	/**************************************************************/
	// Lexical Scope for Visibility/Scope qualifiers - TODO

protected	{ return KW_PROTECTED;	}
public		{ return KW_PUBLIC;		}
published	{ return KW_PUBLISHED;	}
private		{ return KW_PRIVATE;	}

	
 	/**************************************************************/
	// Lexical Scope for Packages
	
package		{ yypushstate(SPACKAGES); yylval = yytext(); return IDENTIFIER; }
<SPACKAGES> {
	requires	{ return KW_REQUIRES; }
	contains	{ return KW_CONTAINS; }
}


 	/**************************************************************/
	/* Built-in types: emitted as identifiers */
/*
		// types: integers
	byte		{ return TYPE_BYTE; }
	shortint	{ return TYPE_SHORTINT; }
	word		{ return TYPE_WORD; }
	smallint	{ return TYPE_SMALLINT; }
	cardinal	{ return TYPE_CARDINAL; }
	integer		{ return TYPE_INT; }
	longword	{ return TYPE_LONGWORD; }
	longint		{ return TYPE_LONGINT; }
	int64		{ return TYPE_INT64; }
	uint64		{ return TYPE_UINT64; }
	comp		{ return TYPE_COMP; }

		// types: floats
	single		{ return TYPE_FLOAT; }
	real48		{ return TYPE_REAL48; }
	extended	{ return TYPE_EXTENDED; }
	double		{ return TYPE_DOUBLE; }
	real		{ return TYPE_DOUBLE; }
	currency	{ return TYPE_CURR; }

		// types: chars 
	char		{ return TYPE_CHAR; }
	pchar		{ return TYPE_PCHAR; }
	ansichar	{ return TYPE_PCHAR; }
	widechar	{ return TYPE_WIDECHAR; }
	shortstring	{ return TYPE_SHORTSTR; }
	widestring	{ return TYPE_WIDESTR; }
	ansistring	{ return TYPE_STR; }
	 
		// types others
	boolean		{ return TYPE_BOOL; }
	olevariant	{ return TYPE_OLEVAR; }
	variant		{ return TYPE_VAR; }
*/

string		{ return TYPE_STR; }
array		{ return TYPE_ARRAY; }
pointer		{ return TYPE_PTR; }
file		{ return TYPE_FILE; }
set			{ return TYPE_SET; }
		

	/**************************************************************/
	/* ASM x86 */

asm						{	yypushstate(XASMCODESEC);
							return KW_ASM;
						}
<XASMCODESEC> {
 [ \t\r]+				{ }
 end					{	yypopstate();
							return KW_END;
						}
	// ignore IDs that start with 'end'
 {ID1}{ID}*			{ }

 .|{NL}					{ }	// return ASM_OP; }
}


	/**************************************************************/
	/* Literals	*/
	
	/* literals: numeric */
{DEC}+				{ yylval = GetInt(yytext(),10); return CONST_INT; }
\${HEXA}+			{ yylval = GetInt(yytext().Substring(1), 16); return CONST_INT; }
nil					{ return CONST_NIL; }
{DEC}+\.{DEC}+		{ yylval = GetReal(yytext()); return CONST_REAL; }
{DEC}+e[+-]?{DEC}+	{ yylval = GetReal(yytext()); return CONST_REAL; }
{DEC}+\.{DEC}+e[+-]?{DEC}+	{ yylval = GetReal(yytext()); return CONST_REAL; }
	
	/* literals: Alphanumeric */
'.'					{ yylval = yytext()[1]; return CONST_CHAR; }
	// check that num < 255
\#{DEC}+			{ yylval = GetInt(yytext().Substring(1), 10); return CONST_CHAR; }
\#\${HEXA}+			{ yylval = GetInt(yytext().Substring(2), 16); return CONST_CHAR; }
'[^']*'				{ yylval = yytext().Substring(1, yylength()-2); return CONST_STR; }

true				{ yylval = true;  return CONST_BOOL; }
false				{ yylval = false; return CONST_BOOL; }


	/**************************************************************/
	/* Operators	*/
	
	/* separators */
":"			{ return COLON; }
","			{ return COMMA; }
"["			{ return LBRAC; }
"("			{ return LPAREN; }
"]"			{ return RBRAC;	}

";"			{	if (yylaststate() == XFUNCDIRECTS)
					yypopstate();
				return SCOL;
			}

")"			{	if (yylaststate() == XFUNCW_RET)
					yypopstate();
				return RPAREN;
			}

	/* expr: general */
":="		{ return KW_ASSIGN; }
".."		{ return KW_RANGE; }
as			{ return KW_AS; }	// cast

	/* expr: unary pointer access */
"."			{ return KW_DOT; }
"@"			{ return KW_ADDR; }
"^"			{ return KW_DEREF; }

	/* expr: numeric operators */
"-"			{ return KW_SUB; }
"+"			{ return KW_SUM; }
"/"			{ return KW_DIV; }
"*"			{ return KW_MUL; }
div			{ return KW_QUOT;}
mod			{ return KW_MOD; }

	/* expr: logical operators */
and			{ return KW_AND; }
or			{ return KW_OR;	 }
xor			{ return KW_XOR; }
shl			{ return KW_SHL; }
shr			{ return KW_SHR; }
not			{ return KW_NOT; }

	/* expr: comparison operators */
"<"			{ return KW_LT; }
">"			{ return KW_GT; }
">="		{ return KW_GE; }
"<="		{ return KW_LE; }
"="			{ return KW_EQ; }
"<>"		{ return KW_NE; }
is			{ return KW_IS; }	// type comp
in			{ return KW_IN; }	// is in set




	/**************************************************************/

{ID1}{ID}*		{ yylval = yytext(); return IDENTIFIER; }

[ \t]+				{ }     /* ignore whitespace */

{NL}				{ }

<<EOF>>				{	return Accept(); }

.					{ yyerror("Unknown char: " + text + " (ASCII " + ((int) text[0]) +")"); }



	/************************************************************/
	/* Obscure/Non-portable/Deprecated keywords: not supported	*/
	
	/* file warnings */
	/*
	platform	{ return KW_PLATFORM; }
	deprecated	{ return KW_DEPRECATED; }
	*/

	/* Embarcadero Delphi directives - ignored
	delayed experimental final
	helper operator reference
	sealed static strict unsafe
	*/

	/*		// windows/forms/COM specific - ignored
	winapi		{ return KW_WINAPI; }
	message		{ return KW_MESSAGE; }
	dispinterface	{ return KW_DISPINTERF; }
	dispid		{ return KW_DISPID; }
	automated	{ return KW_AUTOMATED; }	// visibilidade
		// properties modifiers for dispinterface
	writeonly	{ return KW_WRITEONLY; }
	readonly	{ return KW_READONLY; }
	*/

%%

}	// close outermost namespace
