using System;
using System.Collections;
using System.IO;
using System.Text;

namespace crosspascal.parser
{

/**
 * Delphi Lexer
 * Generated by C# Flex, based on <a href="http://www.jflex.de/">JFlex</a>.
 */
 
%%

	// TODO make a debug option programatically configurable	
// %debug
// %standalone

	
	// %public %abstract
%class DelphiScanner
%implements Token, yyParser.yyInput
//%extends 
%function token

%8bit
	// %unicode

// ------------------------------------------------------
// EOF treatment:
%integer	// eof type. same as: %type Int32

/*	// Use explicit <<EOF>> rules instead 
%eofval{
	// code to be injected in non-specified <STATE><<EOF>> rules
	return YYEOF;
%eofval}
*/

// %eofclose	// close the stream at EOF
%eof{
	// code to be injected in zzDoEOF() if (!zzEOfDone)
	zzEOFDone = false;	// revert changes of zzDoEOF()! Should only apply to the top-level stream
%eof}
// ------------------------------------------------------

	// useless for C#
	// %yylexthrow ScannerException

//%column
%line
	//Delphi is case insensitive
%ignorecase

%x XCOMMENT1 XCOMMENT2 ASMCODESEC XINCLUDED XINC_COM1 XINC_COM2


%{
	
	// **********************************************
	// Preprocessing
	
		public PreProcessor preproc;
	
		Stack<Bool> defines = new Stack<Bool>();
	
		bool TestDefineDir(string dir)
		{
			Boolean defined = preproc.IsDefined(GetDirectiveArg(dir));
			defines.push(defined);
			return defined;
		}

	// **********************************************
	// yyParser.yyLex interface:
	
		/** move on to next token.
			@return false if positioned beyond tokens.
			@throws IOException on input error.
		*/
		public bool advance ()
		{
			return !zzAtEOF;
		}
		
		/** classifies current token.
			Should not be called if advance() returned false.
			@return current %token or single character.
		*/
		// public int token ();
		
		/** associated with current token.
			Should not be called if advance() returned false.
			@return value for token().
		*/
		
		Object yylval;	// value of last token
		public Object value ()
		{
			return yylval;
		}
		
		
	// **********************************************
	// Make CSFlex compatible with FLex:
		
	  	void BEGIN(int state) { yybegin(state); }
		void unput(char c) { yypushback(1); }
		const int INITIAL = YYINITIAL;

		void yyprint(String msg)
		{
			Console.Out.WriteLine("[Line " + yyline + "] " + msg);
		}
		
		void yyerror(String msg = "Unknown lexical error")
		{
		//	throw new ScannerException(yyline, msg);
			Console.Error.WriteLine("[ERROR lexical] " + msg + " in line " + line);
		}
		
		void pperror(String msg = "Unknown preprocessing error")
		{
		//	throw new PreprocessorException(yyline, msg);
			Console.Error.WriteLine("[ERROR preprocessor] " + msg + " in line " + line);
		}

		// Finish scanning
		public int Accept()
		{
		    if (!zzEOFDone) {
				zzEOFDone = true;
				yyclose();
			}
			return YYEOF;
		}
		
		public int yylineno() {
			return yyline;
		}
		

		// **********************************************
		
		// Internal helper functions
		
		// Avoid repeated string creations in yytext. Must reset text to null before each rule's action.
		string _text;
		string text {
			get { 
				if (_text == null)
					_text = yytext();
				return _text;
			}
			set { _text = value; }
		}
		
		Int32 GetInt(string str, int numbase) { return Convert.ToInt32(str, numbase); }
		Double GetReal(string str) { return Convert.ToDouble(str); }

		string GetDirectiveArg(string directive)
		{
			int ignlen = directive.Length + 2; // from: "{$"
			return yytext().Substring(ignlen, yylength()-1-ignlen).Trim();
		}
	
	
%}

%init{
	// code injected in the constructor

	// Inits the scanner
	yyreset(@in);
	// set yylval and text to null before each executing each rule's action
	PRE_ACTION_DEFAULT = () => { yylval = null; text = null; };

%init}

DEC     = [0-9]
HEXA    = [0-9a-fA-F]
ALPH	= [a-zA-Z]
ID      = [0-9a-zA-Z_]
NL      = (\r|\n|\r\n)
	

%%


	/**************************************************************/
	/* Reserved keywords	*/

	/* file type */
library		{ return KW_LIBRARY; }
unit		{ return KW_UNIT; }
program		{ return KW_PROGRAM; }

	/* dependencies */
uses		{ return KW_USES; }
exports		{ return KW_EXPORTS; }

	/* units keywords */
interface	{ return KW_INTERF; }
implementation	{ return KW_IMPL; }
finalization	{ return KW_FINALIZ; }
initialization	{ return KW_INIT; }

	/* objects */
object		{ return KW_OBJECT; }
record		{ return KW_RECORD; }
class		{ return KW_CLASS; }
packed		{ return KW_PACKED; }		// packed struct
of			{ return KW_OF; }			// decl of types

	/* functions */
function	{ return KW_FUNCTION; }
procedure	{ return KW_PROCEDURE; }
property	{ return KW_PROPERTY; }		
inherited	{ return KW_INHERITED; }	// call of base construcotr/methods

	/* section headers */
const		{ return KW_CONST; }
var			{ return KW_VAR; }
out			{ return KW_OUT; }			// modifier of func params
threadvar	{ return KW_THRVAR; }
type		{ return KW_TYPE; }
constructor	{ return KW_CONSTRUCTOR; }
destructor	{ return KW_DESTRUCTOR; }

	/* blocks */
begin		{ return KW_BEGIN; }
end			{ return KW_END; }
with		{ return KW_WITH; }		// with x do ..
do			{ return KW_DO; }

	/* control flow: loops */
for			{ return KW_FOR; }
to			{ return KW_TO; }
downto		{ return KW_DOWNTO; }
repeat		{ return KW_REPEAT; }
until		{ return KW_UNTIL; }
while		{ return KW_WHILE; }

	/* control flow: others */
if			{ return KW_IF; }
then		{ return KW_THEN; }
else		{ return KW_ELSE; }
case		{ return KW_CASE; }		/* switch */
goto		{ return KW_GOTO; }
label		{ return KW_LABEL; }

	/* control flow: exceptions */
raise		{ return KW_RAISE; }
at			{ return KW_AT; }	// ex: raise excpt at address
try			{ return KW_TRY; }
except		{ return KW_EXCEPT; }
finally		{ return KW_FINALLY; }
on			{ return KW_ON; }


	/**************************************************************
	 * Directives:
	 * Should be treated as identifiers instead of reserved keywords
	/**************************************************************/

	/*	properties keywords 
	default		{ return KW_DEFAULT; }
	index		{ return KW_INDEX; }
	implements	{ return KW_IMPLEMENTS; }
	name		{ return KW_NAME; }
	nodefault	{ return KW_NODEFAULT; }
	read		{ return KW_READ; }
	stored		{ return KW_STORED; }
	write		{ return KW_WRITE; }
	*/

	/* scope qualifiers */
protected	{ return KW_PROTECTED; }
public		{ return KW_PUBLIC; }
published	{ return KW_PUBLISHED; }
private		{ return KW_PRIVATE; }

	/* function call types */
cdecl		{ return KW_CDECL; }
pascal		{ return KW_PASCAL; }
mwpascal	{ return KW_PASCAL; }
register	{ return KW_REGISTER; }
safecall	{ return KW_SAFECALL; }
stdcall		{ return KW_STDCALL; }

	/* function qualifiers */
absolute	{ return KW_ABSOLUTE; }
abstract	{ return KW_ABSTRACT; }
assembler	{ return KW_ASSEMBLER; }
dynamic		{ return KW_DYNAMIC; }
export		{ return KW_EXPORT; }
external	{ return KW_EXTERNAL; }
forward		{ return KW_FORWARD; }
inline		{ return KW_INLINE; }
override	{ return KW_OVERRIDE; }
overload	{ return KW_OVERLOAD; }
reintroduce	{ return KW_REINTRODUCE; }
virtual		{ return KW_VIRTUAL; }
varargs		{ return KW_VARARGS; }

	/* file warnings */
platform	{ return KW_PLATFORM; }
deprecated	{ return KW_DEPRECATED; }

	/* packages 
	package		{ return KW_PACKAGE; }
	requires	{ return KW_REQUIRES; }
	contains	{ return KW_CONTAINS; }
	*/

	/* Embarcadero Delphi directives - ignored
	delayed experimental final
	helper operator reference
	sealed static strict unsafe
	*/

	/*		// windows/forms/COM specific - ignored
	winapi		{ return KW_WINAPI; }
	message		{ return KW_MESSAGE; }
	dispinterface	{ return KW_DISPINTERF; }
	dispid		{ return KW_DISPID; }
	automated	{ return KW_AUTOMATED; }	// visibilidade
		// properties modifiers for dispinterface
	writeonly	{ return KW_WRITEONLY; }
	readonly	{ return KW_READONLY; }
		// DOS deprecated
	far			{ return KW_FAR; }
	near		{ return KW_NEAR; }
	resident	{ return KW_RESIDENT; }
	*/


	/* types: integers */
byte		{ return TYPE_BYTE; }
shortint	{ return TYPE_SHORTINT; }
word		{ return TYPE_WORD; }
smallint	{ return TYPE_SMALLINT; }
cardinal	{ return TYPE_CARDINAL; }
integer		{ return TYPE_INT; }
longword	{ return TYPE_LONGWORD; }
longint		{ return TYPE_LONGINT; }
int64		{ return TYPE_INT64; }
uint64		{ return TYPE_UINT64; }

	/* types: floats */
single		{ return TYPE_FLOAT; }
real48		{ return TYPE_REAL48; }
extended	{ return TYPE_EXTENDED; }
double		{ return TYPE_DOUBLE; }
real		{ return TYPE_DOUBLE; }

	/* types: chars */
char		{ return TYPE_CHAR; }
pchar		{ return TYPE_PCHAR; }
ansichar	{ return TYPE_PCHAR; }
widechar	{ return TYPE_WIDECHAR; }
string		{ return TYPE_STR; }
shortstring	{ return TYPE_SHORTSTR; }
widestring	{ return TYPE_WIDESTR; }
ansistring	{ return TYPE_STR; }
resourcestring	{ return TYPE_RSCSTR; }
 
	/* types others */
boolean		{ return TYPE_BOOL; }
olevariant	{ return TYPE_OLEVAR; }
variant		{ return TYPE_VAR; }
comp		{ return TYPE_COMP; }
currency	{ return TYPE_CURR; }
array		{ return TYPE_ARRAY; }
pointer		{ return TYPE_PTR; }
file		{ return TYPE_FILE; }
set			{ return TYPE_SET; }
	

	/**************************************************************/
	/* ASM x86 */

asm						{	BEGIN(ASMCODESEC);
							return KW_ASM;
						}

<ASMCODESEC>[ \t\r]+	{ }
<ASMCODESEC>end;		{	// HACK!!! temporary. must change
							unput(';');
							BEGIN(INITIAL);
							return KW_END;
						}
<ASMCODESEC>{NL}		{ }
<ASMCODESEC>.			{ return ASM_OP; }	// ASM unknown char


	/**************************************************************/
	/* Literals	*/
	
	/* literals: numeric */
{DEC}+				{ yylval = GetInt(yytext(),10); return CONST_INT; }
\${HEXA}+			{ yylval = GetInt(yytext().Substring(1), 16); return CONST_INT; }
nil					{ return CONST_NIL; }
{DEC}+\.{DEC}+		{ yylval = GetReal(yytext()); return CONST_REAL; }
{DEC}+e[+-]?{DEC}+	{ yylval = GetReal(yytext()); return CONST_REAL; }
{DEC}+\.{DEC}+e[+-]?{DEC}+	{ yylval = GetReal(yytext()); return CONST_REAL; }
	
	/* literals: ALPHnumeric */
\'.\'				{ yylval = yytext()[1]; return CONST_CHAR; }
	// check that num < 255
\#{DEC}+			{ yylval = GetInt(yytext().Substring(1), 10); return CONST_CHAR; }
\#\${HEXA}+			{ yylval = GetInt(yytext().Substring(2), 16); return CONST_CHAR; }
''					{ yylval = ""; return CONST_STR; }
'[^']*'				{ yylval = yytext().Substring(1, yylength()-2); return CONST_STR; }

true				{ yylval = true;  return CONST_BOOL; }
false				{ yylval = false; return CONST_BOOL; }


	/**************************************************************/
	/* Operators	*/
	
	/* separators */
":"			{ return COLON; }
","			{ return COMMA; }
";"			{ return SEMICOL;}
"["			{ return LBRAC; }
"("			{ return LPAREN;}
"]"			{ return RBRAC;	}
")"			{ return RPAREN;}

	/* expr: general */
":="		{ return KW_ASSIGN; }
".."		{ return KW_RANGE; }
as			{ return KW_AS; }	// cast

	/* expr: unary pointer access */
"."			{ return KW_DOT; }
"@"			{ return KW_ADDR; }
"^"			{ return KW_DEREF; }

	/* expr: numeric operators */
"-"			{ return KW_SUB; }
"+"			{ return KW_SUM; }
"/"			{ return KW_DIV; }
"*"			{ return KW_MUL; }
div			{ return KW_QUOT;}
mod			{ return KW_MOD; }

	/* expr: logical operators */
and			{ return KW_AND; }
or			{ return KW_OR;	 }
xor			{ return KW_XOR; }
shl			{ return KW_SHL; }
shr			{ return KW_SHR; }
not			{ return KW_NOT; }

	/* expr: comparison operators */
"<"			{ return KW_LT; }
">"			{ return KW_GT; }
">="		{ return KW_GE; }
"<="		{ return KW_LE; }
"="			{ return KW_EQ; }
"<>"		{ return KW_DIFF; }
is			{ return KW_IS; }	// type comp
in			{ return KW_IN; }	// is in set



	/**************************************************************/
	/* PreProcessor - process compiler directives */
	
	/* includes */
"{$i "[^}]+\}		{
						string fpath = GetDirectiveArg("i");
						string incpath = preproc.SearchFile(fpath);
						
						if (incpath == null)
							pperror("Include file " + incpath + " not found");
						else
						{
							StreamReader sr = null;
							try {
								sr = new StreamReader(incpath, DelphiParser.DefaultEncoding);
							} 
							catch (IOException ioe) {
								pperror("Include file " + fpath + " could not be read: " + ioe.Message);
							}
							finally {
								yypushStream(sr);
								yyprint("PUshed stream from " + fpath + "");
							}
						}
					}

	/* defines */
"{$define "[^}]\}	{	preproc.AddDefine(GetDirectiveArg("define"));	}

"{$undef "[^}]\}	{	preproc.RemoveDefine(GetDirectiveArg("undef"));	}

	/* ifdefs */
"{$ifdef "[^}]\}	{	if (!IsDefinedDir("ifdef"))
							BEGIN(XNOTDEF);
					}

"{$ifopt "[^}]\}	{	if (!IsDefinedDir("ifopt"))
							BEGIN(XNOTDEF);
					}

"{$ifndef "[^}]\}	{	if (IsDefinedDir("ifndef"))
							BEGIN(XNOTDEF);
					}

"{$else"[^}]\}		{	Boolean def = defines.pop();
						if (!def)
							BEGIN(XNOTDEF);
						defines.push(!def);
					}

"{$endif"[^}]\}		{	Boolean def = defines.pop(); }


	/* not-defined code section */
<XNOTDEF> {
					/* push true to signal that these defines are within a non-defined section */
 "{$ifdef "[^}]\}	{	defines.push(true);	}

 "{$ifopt "[^}]\}	{	defines.push(true);	}

 "{$ifndef "[^}]\}	{	defines.push(true);	}

 "{$else"[^}]\}		{	if (defines.Peek() == false)	// at the non-def section start, must leave
						{	BEGIN(INITIAL);
							defines.pop();
							defines.push(true);
						} // else, leave the top def as true
					}

 "{$endif"[^}]\}	{	Boolean def = defines.pop(); 
						if (def == false)
							BEGIN(INITIAL);
					}
 
 .|\n				{ }
 <<EOF>>			{	throw new ScannerException(yyline, "Encountered EOF while inside a compiler directive"); }
}

	/* Other compiler directives: ignored */
"{$"[^}]\}		{ }




	/**************************************************************/
	/* Comments		*/
	
"//".*			{ } // single line comment

				/* multi-line comments */
\{				{ BEGIN(XCOMMENT1); }
<XCOMMENT1>\}	{ BEGIN(INITIAL); }

\(\*			{ BEGIN(XCOMMENT2); }
<XCOMMENT2>\*\)	{ BEGIN(INITIAL); }

<XCOMMENT2,XCOMMENT1>{NL}	{ }
<XCOMMENT2,XCOMMENT1>.		{ }  // Console.WriteLine("READ comment state: " + yytext() + " ascii: " + (int) yytext()[0] + " <<"); }



	/**************************************************************/

[_a-zA-Z]{ID}*	{ yylval = yytext(); return IDENTIFIER; }


[ \t]+			{ }     /* ignore whitespace */

{NL}			{ }

<<EOF>>			{	if (yymoreStreams())
					{	yypopStream();
						yyprint("Popped stream and began initial state");
					}
					else
					{
						if (defines.Count > 0)
							throw new ScannerException(yyline, "Encountered EOF while inside a compiler directive"); }
						else
							return Accept(); /* top-level yyclose() */
					}
				}
					

.				{ yyerror("Unknown char: " + text + " (ASCII " + ((int) text[0]) +")"); }


%%

	
	// Auxiliary 

	class LexErrorMessages
	{
		const string UnkownChar = "Unknown character";
		
		const string InvalidInteger = "Invalid Integer Format";
		const string InvalidReal = "Invalid Real Format";
		const string UnterminatedComment = "Block Comment not closed";
		
		// TODO all the Scanner's error messages here
	}

		
	class ScannerException : Exception
	{
		internal ScannerException(int line, string msg = "Scanner Error")
			: base(msg + " in line " + line) { }
		
		internal ScannerException(string msg = "Scanner Error") : base(msg) { }
	}
	
	class PreprocessorException : Exception
	{
		internal PreprocessorException(int line, string msg = "Preprocessor Error")
			: base(msg + " in line " + line) { }

		internal PreprocessorException(string msg = "Preprocessor Error") : base(msg) { }
	}


}	// close outermost namespace
